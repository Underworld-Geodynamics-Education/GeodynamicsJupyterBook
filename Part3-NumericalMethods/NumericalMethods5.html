

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Methods for Solving Numerical Problems &#8212; Geodynamics with Underworld</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/spanels-index--0afa1ebdab0bb23b98b56d34c23d9f57.css" />
    <link rel="stylesheet" type="text/css" href="../_static/spanels-variables--ffc7f74dcb1b9eecba2dbcbc22818714.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Python for Earth Scientists" href="../Part2-Python/0-StartHere.html" />
    <link rel="prev" title="Practical Finite Elements" href="NumericalMethods4.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/MundusSubterraneus.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Geodynamics with Underworld</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../FrontPage.html">
   Geodynamics with Underworld
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Introduction and Background
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../Part0-Introduction/Introduction.html">
   Introduction
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Mathematical Fluid Dynamics
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../Part1-FluidDynamics/ContinuumMechanics.html">
   Conservation Laws
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Part1-FluidDynamics/NavierStokes.html">
   Navier-Stokes Equation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Part1-FluidDynamics/MantleDynamics.html">
   Non-dimensional equations &amp; dimensionless numbers
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Part1-FluidDynamics/ThermalConvection.html">
   Thermal Convection
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Part1-FluidDynamics/LithosphericDynamics.html">
   Dynamics of the Lithosphere
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Numerical Modeling
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="NumericalMethods1.html">
   Numerical Modeling in Solid Earth Dynamics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="NumericalMethods2.html">
   Survey of numerical methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="NumericalMethods3.html">
   Introduction to the Finite Element Method
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="NumericalMethods4.html">
   Practical Finite Elements
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Methods for Solving Numerical Problems
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Python for Geoscientists
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../Part2-Python/0-StartHere.html">
   Python for Earth Scientists
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Part2-Python/NumpyAndScipy/0-NumpyAndScipy.html">
   Numpy and Scipy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Part2-Python/Plotting/1-IntroductionToMatplotlib.html">
   Introduction to matplotlib
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Part2-Python/Mapping/00-Maps_with_Cartopy.html">
   Maps with the Cartopy Package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Part2-Python/SphericalMeshing/0-Stripy.html">
   Triangulations
  </a>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/Part3-NumericalMethods/NumericalMethods5.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/Underworld-Geodynamics-Education/GeodynamicsJupyterBook"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        
        
    </div>
</div>


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#solving-the-matrix-problem">
   Solving the matrix problem
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#jacobi-relaxation">
     Jacobi relaxation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#gauss-seidel-relaxation">
     Gauss-Seidel relaxation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#conjugate-gradients">
     Conjugate Gradients
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multigrid">
     Multigrid
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-practical-mixed-formulation">
   A Practical Mixed Formulation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#time">
   Time
  </a>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="methods-for-solving-numerical-problems">
<h1>Methods for Solving Numerical Problems<a class="headerlink" href="#methods-for-solving-numerical-problems" title="Permalink to this headline">¶</a></h1>
<div class="math notranslate nohighlight">
\[
\newcommand{\dGamma}{\mathbf{d}\boldsymbol{\Gamma}}
\newcommand{\erfc}{\mbox{\rm erfc}}
\newcommand{\curly}{\sf }
\newcommand{\Red     }[1]{\textcolor[rgb]{0.7,0.0,0.0}{ #1}} 
\newcommand{\Green   }[1]{\textcolor[rgb]{0.0,0.7,0.0}{ #1}} 
\newcommand{\Blue    }[1]{\textcolor[rgb]{0.0,0.0,0.7}{ #1}} 
\newcommand{\Emerald }[1]{\textcolor[rgb]{0.0,0.7,0.3}{ #1}} 
\]</div>
<div class="section" id="solving-the-matrix-problem">
<h2>Solving the matrix problem<a class="headerlink" href="#solving-the-matrix-problem" title="Permalink to this headline">¶</a></h2>
<p>Once the problem has been rendered into a matrix form, the finite element part is over !  The rest is matrix algebra. There are a number of standard techniques for solving such systems which we briefly outline in the context of the Earth dynamics problem. In most dynamic systems, the FEM can be formulated in a time-explicit manner (cf discrete element methods) that is robust and simple to implement, or using implicit methods which are more elaborate and are often more temperamental but which are capable of covering much larger time increments at each step. In our case, however, the fact that inertia is negligible, leaves the equation of motion independent of time and it can only be solved implicitly.</p>
<p>The original implicit solver in FEM was to build the matrix equation and solve it directly using an method such as Crout elimination. This can be done relatively efficiently by exploiting the fact that the finite element matrices are quite tightly banded.  Unfortunately, direct solution methods are limited to “small” problems since the solution-time scales very rapidly with the number of unknowns (in the worst case, as <span class="math notranslate nohighlight">\(N^3\)</span> where <span class="math notranslate nohighlight">\(N\)</span> is the number of unknowns, and even in the best case as <span class="math notranslate nohighlight">\(N^2\)</span>).</p>
<p>Iterative methods can achieve much better performance than this once the problems start to become larger. For example, preconditioned conjugate gradient methods can obtain a solution to a given accuracy in a time proportional to <span class="math notranslate nohighlight">\(N\log N\)</span>. However, preconditioning can be highly time consuming and may need careful tailoring for different problems as the iterations may not converge (compare this to our need to carefully choose how to discretise problems in our finite difference examples earlier)</p>
<p>The optimal method, in theory, for the Stokes problem is <em>multigrid</em> which, when properly formulated, can find a solution in a time proportional to <span class="math notranslate nohighlight">\(N\)</span>.</p>
<p>An additional problem arises with direct methods. The number of unknowns in the vector <span class="math notranslate nohighlight">\(\mathbf{d}\)</span> is slightly less than <span class="math notranslate nohighlight">\(n_{\rm dim}\)</span> times the number of nodal points once the prescribed boundary velocities have been included. For a well-resolved problem the stiffness matrix <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> is often too large to be stored in full, even accounting for its sparsity. Some iterative methods can operate with only the element stiffness matrices which can be built and used on the fly. Although this requires significantly more computations, it can make some large problems soluble where otherwise memory limitations would block solution. It is also possible that computation can be more efficient than retrieving carefully-packed matrix coefficents and, in this case, element-by-element methods can be competitive for speed in their own right.</p>
<p>Some simple iterative schemes {\bf for positive definite systems} are described next. Far more that this exist and many are more efficient but this usually depends on the actual application area.</p>
<div class="section" id="jacobi-relaxation">
<h3>Jacobi relaxation<a class="headerlink" href="#jacobi-relaxation" title="Permalink to this headline">¶</a></h3>
<p>One of the simplest iterative methods of residual reduction is the Jacobi iteration. Given an approximate solution, <span class="math notranslate nohighlight">\(\mathbf{d}^{(0)}\)</span>, to <span class="math notranslate nohighlight">\(\mathbf{Kd}=\mathbf{f}\)</span>, an improved solution, <span class="math notranslate nohighlight">\( \mathbf{d}^{(1)}\)</span> is found by</p>
<div class="math notranslate nohighlight">
\[ 
  d_i^{(1)} = \left( f_i - \sum^{n}_{j=1;j\not=i} k_{ij}d_j^{(0)} \right) / k_{ii}
\]</div>
<p>It is clear that each iteration cycle requires only one matrix-vector multiplication. However, the convergence rate for this algorithm is usually poor and a large number of cycles is required.</p>
</div>
<div class="section" id="gauss-seidel-relaxation">
<h3>Gauss-Seidel relaxation<a class="headerlink" href="#gauss-seidel-relaxation" title="Permalink to this headline">¶</a></h3>
<p>A trivial modification to the Jacobi iteration is to use updated information on the <span class="math notranslate nohighlight">\(\mathbf{d}\)</span> componenents immediately they become available. This results in the Gauss-Seidel iteration which is considerably more efficient than Jacobi. It can, however, be harder to code efficiently because the independence of each degree of freedom during one iteration disappears.</p>
</div>
<div class="section" id="conjugate-gradients">
<h3>Conjugate Gradients<a class="headerlink" href="#conjugate-gradients" title="Permalink to this headline">¶</a></h3>
<p>A more sophisticated iterative procedure for obtaining solutions to linear systems is the conjugate gradient method. This is a development of the method of steepest descent with better convergence properties. The `search directions’ along which the solution is improved are denoted by <span class="math notranslate nohighlight">\(\mathbf{s}\)</span> and do not coincide with the residual vectors. In the following algorithm an inner product is denoted by <span class="math notranslate nohighlight">\((\cdot,\cdot)\)</span>.</p>
<div class="admonition-conjugate-gradient-algorithm admonition">
<p class="admonition-title">Conjugate Gradient Algorithm</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(k=0; \mathbf{u}_0 = {\bf 0}; \mathbf{r}_0 = \mathbf{f}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> while <span class="math notranslate nohighlight">\((\mathbf{r}_k \not= {\bf 0})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(k = k + 1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  if <span class="math notranslate nohighlight">\((k=1)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\mathbf{s}_1 = \mathbf{r}_0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  else</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\(\beta = (\mathbf{r}_{k-1},\mathbf{r}_{k-1})/(\mathbf{r}_{k-2},\mathbf{r}_{k-2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\(\mathbf{s}_k = \mathbf{r}_{k-1} + \beta \mathbf{s}_{k-1}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  end</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\alpha = (\mathbf{r}_{k},\mathbf{r}_{k})/(\mathbf{s}_{k},{\bf A s}_{k})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\mathbf{u}_k = \mathbf{u}_{k-1} + \alpha \mathbf{s}_{k}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\mathbf{r}_k = \mathbf{r}_{k-1} - \alpha {\bf As}_{k}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> end</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\mathbf{u} = \mathbf{u}_k\)</span></p></li>
</ol>
</div>
<p>In this case the use of residual vectors from previous iteration steps is necessary to ensure that there is only one matrix-vector multiplication. The convergence of the conjugate gradient algorithm is fastest when <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> is close to the identity matrix. For a general matrix the reduction of the residual may be  slow through the first few iterations then picks up speed as the procedure progresses. This property makes this iterative loop inefficient for relatively small numbers of iterations.</p>
<p>Note that the reduction of the residual is a measure of “improvement” of the solution which is internal to the iteration. Although the magnitude of the residual is usually reduced monotonically, the true error, when it can be calculated, may increase as well as decrease. In order to improve the rate of convergence it is necessary to reformulate the problem such that the solution to a <em>nearly diagonal</em> system is sought. This procedure is known as preconditioning. The system <span class="math notranslate nohighlight">\(\mathbf{Kd} = \mathbf{f}\)</span> is transformed to a case which can be solved more rapidly by the conjugate gradient algorithm:</p>
<div class="math notranslate nohighlight">
\[
    \tilde{\mathbf{K}}\tilde{\mathbf{u}} = \tilde{\mathbf{f}}
\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split} 
    \begin{align*}
      \tilde{\mathbf{K}} &amp;= {\bf C}^{-1}\mathbf{K} {\bf C}^{-1}\\
      \tilde{\mathbf{u}} &amp;= {\bf Cu}   \\
      \tilde{\mathbf{f}} &amp;= {\bf C}^{-1} {\bf b}
    \end{align*}
\end{split}\]</div>
<p>The preconditioning matrix <span class="math notranslate nohighlight">\(\bf M\)</span> is defined by <span class="math notranslate nohighlight">\({\bf M} = {\bf C}^2\)</span>, and  the preconditioned
conjugate gradient algorithm is then:</p>
<div class="admonition-preconditioned-conjugate-gradient-algorithm admonition">
<p class="admonition-title">Preconditioned Conjugate Gradient Algorithm</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\( k = 0; \mathbf{u}_0 = {\bf 0}; \mathbf{r}_0 = \mathbf{f}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  while <span class="math notranslate nohighlight">\((\mathbf{r}_k \not= {\bf 0})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>   <em>solve</em> <span class="math notranslate nohighlight">\({\bf M z}_k = \mathbf{r}_k\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\( k = k + 1 \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>   if <span class="math notranslate nohighlight">\((k=1)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\mathbf{s}_1 = {\bf z}_0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>   else</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\beta = (\mathbf{r}_{k-1},{\bf z}_{k-1})/(\mathbf{r}_{k-2},{\bf z}_{k-2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\(\mathbf{s}_k = {\bf z}_{k-1} + \beta \mathbf{s}_{k-1}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>   end</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\(\alpha = (\mathbf{r}_{k},{\bf z}_{k})/(\mathbf{s}_{k},{\bf A s}_{k})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\(\mathbf{d}_k = \mathbf{d}_{k-1} + \alpha \mathbf{s}_{k}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\(\mathbf{r}_k = \mathbf{r}_{k-1} - \alpha \mathbf{Ks}_{k}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  end</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\mathbf{d} = \mathbf{d}\mathbf{d}_k\)</span></p></li>
</ol>
</div>
<p>The choice of <span class="math notranslate nohighlight">\(\bf M\)</span> has a dramatic effect on the rate of convergence of the method. Not only must the preconditioner improve the convergence properties of the system, but the solution to <span class="math notranslate nohighlight">\({\bf Mz} = \mathbf{r}\)</span> must be inexpensive. Clearly if <span class="math notranslate nohighlight">\({\bf M} = \mathbf{K}\)</span> then exact convergence is obtained in one iteration but the solution of the preconditioning step becomes impossible. The simplest preconditioner, and the one employed here, is to set <span class="math notranslate nohighlight">\({\bf M} = \mathrm{diag}(\mathbf{K})\)</span>. This is not only simple to calculate (and invert) but requires very little storage. For simple systems the reduction of the residual is noticeably improved during the initial iterations. However, it is not clear how well this simple preconditioner will work when strong viscosity contrasts are present and off-diagonal terms in <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> may be large.</p>
</div>
<div class="section" id="multigrid">
<h3>Multigrid<a class="headerlink" href="#multigrid" title="Permalink to this headline">¶</a></h3>
<p><img alt="Multigrid: (a) Error reduction during simple two level V cycle, (b) Shape functions on different grid scales, (c) V cycle on four grids, (d) W cycle on four grids, (e) Schematic of Full Multigrid V cycles" src="../_images/mg.png" /></p>
<p>The multigrid method works by formulating the finite element problem on a number of different scales - usually a set of grids which are nested one within the other sharing common nodes.  The solution progresses on all of the grids at the same time with each grid eliminating errors at a different scale. The effect is to propogate information very rapidly between different nodes in the grid which would otherwise be prevented by the local support of the element shape functions. In fact, by a single traverse from fine to coarse grid and back, all nodes in the mesh can be directly connected to every other – allowing nodes which are physically coupled but remote in the mesh to communicate directly during each iteration cycle.</p>
<p>The multigrid effect relies upon using an iterative solver on each of the grid resolutions which acts like a smoother on the residual error at the characteristic scale of that particular grid. People commonly use Gauss-Seidel iteration because it has exactly this property. On the coarsest grid it is possible to use a direct solver because the number of elements is usually very small.</p>
<p>For an elliptic operator such as the Laplacian of the Stokes’ problem encountered in the algorithm above the discretized problem is now written</p>
<div class="math notranslate nohighlight">
\[ 
  {\bf K}_h {\bf d}_h = {\bf f}_h
\]</div>
<p>where  the <span class="math notranslate nohighlight">\(h\)</span> subscript indicates that the problem has been discretized to a mesh of fineness <span class="math notranslate nohighlight">\(h\)</span>.  As before an initial estimate of the velocity can be improved by determining the solution to</p>
<div class="math notranslate nohighlight">
\[ 
  {\bf K}_h \delta {\bf d}_h = {\bf r}_h
\]</div>
<p>where <span class="math notranslate nohighlight">\({\bf r}_h\)</span> is the residual on this mesh, and <span class="math notranslate nohighlight">\(\delta {\bf d}\)</span> is a correction to <span class="math notranslate nohighlight">\(\bf d\)</span> which reduces <span class="math notranslate nohighlight">\(\bf r\)</span>. In the iterative methods described above, the initial approximation and the correction are found by solving a simplified version of the problem at the same gridpoints in such a way that computation time is reduced dramatically. However, another approach to the problem is to obtain an approximate solution by solving the problem on a more coarse grid. The reduction of the number of degrees of freedom also leads to a more manageable problem which can be solved fast. The correction term is therefore:</p>
<div class="math notranslate nohighlight">
\[ 
  {\bf K}_H \delta{\bf d}_H = {\bf r}_H
\]</div>
<p>where <span class="math notranslate nohighlight">\(H\)</span> indicates a coarser level of discretization. The residual on the coarser mesh is determined by the use of a projection (restriction) operator:</p>
<div class="math notranslate nohighlight">
\[ 
  {\bf r}_H = {\bf P}_H^h {\bf r}_h
\]</div>
<p>and the approximate solution is then interpolated from the coarse to fine grid using an interpolation operator:</p>
<div class="math notranslate nohighlight">
\[ 
  \delta{\bf d}_h = {\bf I}_H^h \delta{\bf d}_H
\]</div>
<p>The power of the algorithm is in a recursive application. The coarse grid correction is also calculated through the use of a still-coarser grid and so on, until the problem is so small that an exact solution can be obtained very rapidly. One very simple, but instructive, algorithm for hierarchical residual reduction is the sawtooth cycle (the same logical layout as the <a class="reference external" href="#multigrid-diagram">multigrid V cycle</a>).</p>
<div class="admonition-multigrid-algorithm admonition">
<p class="admonition-title">Multigrid Algorithm</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>   Obtain approximate solution, <span class="math notranslate nohighlight">\({\bf d}_h\)</span> at highest level <span class="math notranslate nohighlight">\(h\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>   Calculate residual: <span class="math notranslate nohighlight">\({\bf r}_h = {\bf f}_h - {\bf K}_h {\bf d}_h\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>   Project residual by N levels to level <span class="math notranslate nohighlight">\(h-N\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\({\bf r}_{h-i} = {\bf  P}_{h-i}^{h-i+1} {\bf r}_{h-i+1}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>   Solve exactly: <span class="math notranslate nohighlight">\(\delta {\bf u}_{h-N} = {\bf A}_{h-N} {\bf r}_{h-N}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>   Interpolation steps:</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\({\bf r}_{h-i+1} += {\bf I}_{h-i}^{h-i+1} {\bf K}_{h-i} \delta {\bf d}_{h-i}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\(\quad\)</span>  Improve <span class="math notranslate nohighlight">\(\delta {\bf d}_{h-i+1}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span>   <span class="math notranslate nohighlight">\({\bf d}_h += \delta {\bf d}_h\)</span></p></li>
</ol>
</div>
<p>The step in which the velocity correction is “improved” is an iterative method for reducing the residual at the current level such as those described above. Although many methods of residual reduction are available, the class of methods which often work best with the multigrid approach are relaxation iterations which are also effective {\sl smoothing} operators. At each level the smoothing operators reduce the residual most strongly on the scale  of the discretization – the hierarchical nesting of different mesh sizes allows the residual to be reduced at each scale very efficiently. (see Parsons and Hall).  The Jacobi relaxation above is a suitable algorithm for multigrid enhancement but still converges too slowly to build into an efficient code. Preconditioned conjugate gradient methods can better reduce the residual for the same number of operations but may not possess the smoothing properties which benefit the multigrid approach. The local inverse method appears to have both the smoothing and rapid convergence properties for the Stokes’ problem which are required for effective multigridding.</p>
<p>The projection and interpolation operators have to be chosen fairly carefully to avoid poor approximations to the problem at the coarse levels and ineffectual corrections propogated to the fine levels. The interpolation operator is defined naturally from the shape functions at the coarse levels. The projection operator is then defined to complement this choice (the operators should be adjoint).</p>
<p>The sawtooth cycle given in this section is the simplest multigrid algorithm. Developments include improving the residual at each level of the {\sl projection}, known as a <em>v-cycle</em>, and cycles in which the residual is interpolated only part way through the hierarchy before being reprojected and subjected to another set of improvements
(a <em>w-cycle</em>).</p>
<p>The Full Multigrid Algorithm (see Brandt) introduces a further level of complexity. Instead of simply casting the problem at a single level and projecting/improving the residual on a number of grids, the whole problem is defined for all the grids. In this way the initial fine-grid approximation is obtained by interpolating from the solution to the coarsest grid problem. The solution at each level is still obtained by projecting to the finest level and reducing the residual at each projection step. The result is some sort of “Loch Ness Monster” cycle.</p>
<p>One of the major problems in multigrid is knowing how best to represent material properties at different levels of grid coarseness in order to obtain the optimal convergence rate. This has a simple solution in the particle in cell finite element methods which we will discuss later.</p>
<!-- Should perhaps switch to a discussion of galerkin MG -->
</div>
</div>
<div class="section" id="a-practical-mixed-formulation">
<h2>A Practical Mixed Formulation<a class="headerlink" href="#a-practical-mixed-formulation" title="Permalink to this headline">¶</a></h2>
<p>The fact that the mixed method does not provide a positive definite matrix is a potentially serious difficulty. It can be avoided by the following rearrangement which forms the Schur complement of the original system.Multiplying out the mixed method equations gives the conservation equations for momentum and mass</p>
<div class="math notranslate nohighlight">
\[ 
        {\bf Kd} + {\bf G}^T{\bf p} = {\bf f} 
        \label{eq:stokes}
\]</div>
<div class="math notranslate nohighlight">
\[ 
        {\bf Gd} = {\bf 0}
\]</div>
<p>Multiply equation \( (\ref{eq:stokes}) \) throughout by <span class="math notranslate nohighlight">\({\bf G}{\bf K}^{-1}\)</span>
to give</p>
<div class="math notranslate nohighlight">
\[ 
{\bf Gd} + {\bf G K}^{-1}{\bf G}^T {\bf p} = {\bf G K}^{-1}{\bf  f}
\]</div>
<p>where the first term is zero due to the incompressibility condition. Then the equation system is in the form <span class="math notranslate nohighlight">\(\hat{\bf K}{\bf p} = \hat{\bf f}\)</span>, where <span class="math notranslate nohighlight">\(\hat{\bf K}\)</span> is  now positive definite, and so a conjugate gradient method can be used:</p>
<div class="admonition-conjugate-gradient-schur-complement admonition">
<p class="admonition-title">Conjugate Gradient, Schur Complement</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\Red{ k = 0; {\bf p}_0 = {\bf 0}; {\bf r}_0 = \hat{\bf f}}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> while <span class="math notranslate nohighlight">\(({\bf r}_k \not= {\bf 0})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\( k = k + 1 \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  if <span class="math notranslate nohighlight">\((k=1)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\({\bf s}_1 = {\bf r}_0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  else</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\beta = ({\bf r}_{k-1},{\bf r}_{k-1})/({\bf r}_{k-2},{\bf r}_{k-2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\({\bf s}_k = {\bf r}_{k-1} + \beta {\bf s}_{k-1}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  end</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\Red{{\bf w} = \hat{\bf K} {\bf s}}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\alpha = ({\bf r}_{k},{\bf r}_{k})/({\bf s}_{k},{\bf w})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\({\bf p}_k = {\bf p}_{k-1} + \alpha {\bf s}_{k}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\({\bf r}_k = {\bf r}_{k-1} - \alpha {\bf w}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> end</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\({\bf d} = {\bf d}_k\)</span></p></li>
</ol>
</div>
<p>However, it is not possible to obtain <span class="math notranslate nohighlight">\(\hat{\bf K}\)</span> or <span class="math notranslate nohighlight">\(\hat{\bf f}\)</span> directly because the form of <span class="math notranslate nohighlight">\({\bf K}^{-1}\)</span> is not known. This means we are stuck on steps 1 and 10 in this algorithm. Luckily, we can still take these steps because we
are only interested in the <em>effect</em> of the operation of the matrix on a given vector. The modification of the algorithm
looks like this:</p>
<div class="admonition-conjugate-gradient-algorithm-no-matrix-construction admonition">
<p class="admonition-title">Conjugate Gradient Algorithm (No Matrix Construction)</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\Green{{\bf r}_0 = {\bf G K}^{-1} {\bf f}}\)</span>:</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\Green{\mathrm{solve:} \;\; {\bf K d} = {\bf f} \;\; \mathrm{for} \;\; \bf d}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\Green{\mathrm{set:} \;\; {\bf r}_0 = {\bf G d} = {\bf G K}^{-1} {\bf f}}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> while <span class="math notranslate nohighlight">\(({\bf r}_k \not= {\bf 0})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\( k = k + 1 \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  if <span class="math notranslate nohighlight">\((k=1)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\({\bf s}_1 = {\bf r}_0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  else</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\beta = ({\bf r}_{k-1},{\bf r}_{k-1})/({\bf r}_{k-2},{\bf r}_{k-2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\({\bf s}_k = {\bf r}_{k-1} + \beta {\bf s}_{k-1}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  end</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\Green{{\bf w} = \hat{\bf G K}^{-1}{\bf G}^T {\bf s}}\)</span>:</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\Green{\textrm{solve:} \;\; {\bf K d} = {\bf G}^T {\bf s} \;\; \textrm{for} \;\; \bf d}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\Green{ \textrm{set:} \;\; {\bf w} = {\bf K d} = {\bf G K}^{-1}{\bf G}^T {\bf s}}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\(\alpha = ({\bf r}_{k},{\bf r}_{k})/({\bf s}_{k},{\bf w})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\({\bf p}_k = {\bf p}_{k-1} + \alpha {\bf s}_{k}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\(\quad\)</span>  <span class="math notranslate nohighlight">\({\bf r}_k = {\bf r}_{k-1} - \alpha {\bf w}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> end</p></li>
<li><p><span class="math notranslate nohighlight">\(\quad\)</span> <span class="math notranslate nohighlight">\({\bf d} = {\bf d}_k\)</span></p></li>
</ol>
</div>
<p>Our assumption is that the matrix, <span class="math notranslate nohighlight">\(\hat{\bf K}\)</span> could not be calculated because it would be too time consuming (and self-defeating) to do so, but it is also possible to imagine a case where we would compute the effect of an operator on
a vector as a result of a black-box operation not</p>
</div>
<div class="section" id="time">
<h2>Time<a class="headerlink" href="#time" title="Permalink to this headline">¶</a></h2>
<p>We have concentrated on the solution to equibrium equations without really touching on the way time is evolved in elasticity and slow flow where the equations themselves are independent of time. In the mantle dynamics problem, the energy equation contains time derivatives which the equation of motion lacks so it is unsurprising that these equations require entirely different computational methods.</p>
<p>We almost always want to know the time-history of our simulations, so we generally solve this equation explicitly or semi-implicitly in time.</p>
<p>Variational methods are not generally applicable because the energy equation with its strong advection term does not follow an extremum of some functional. In this case even the weak forms of the equation are quite similar to finite difference equations.</p>
<!-- MORE - perhaps take some of the treatise article here and expand it --> 
<!-- %## Ideas on a Particle in Cell Finite Element Code}
%   
%   The extension of standard finite element
%   methods to include a basic Lagrangian Particle reference
%   frame. 
%   
%   Adapting integration schemes.
%   
%   Problems for highly active flow regimes.
%
%   Discussion: as this is ongoing, research work with 
%   potentially exciting commercial applications, it will be discussed but
%   not written out here !!
%   
%### Geological Examples from a PIC / FE method}
%
%   To wind down the course, we will watch some movies
%   of finite elements in action. -->
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./Part3-NumericalMethods"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="NumericalMethods4.html" title="previous page">Practical Finite Elements</a>
    <a class='right-next' id="next-link" href="../Part2-Python/0-StartHere.html" title="next page">Python for Earth Scientists</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Louis Moresi<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>